# HostSpot虚拟机对象探秘

>  深入探讨HsotSpot在Java堆中对象分配，布局和访问。

## 对象的创建

> 在我们写Java代码的时候，我们创建对象的时候往往只需要一个new关键字，它就可以把这个对象安排的明明白白。说到这里，再提一下创建对象的几种方式（通过反序列化，通过new，通过克隆）。

对象创建的过程

1. 当虚拟机遇到new指令，先去检查这个指令能否在常量池中定位到一个符号引用并检查这个符号引用所代表的类是否已经被加载,解析，初始化过。如果没有，那就对这个类进行加载（通过类加载器进行加载，双亲委派，多亲等）。

2. 类加载通过后，然后虚拟机就该给这个新的类分配内存空间了。对象所需要的空间在加载完成后已经是确定的了，在前面JVM内存区中，基本所有的对象都分配在堆里，因此也就是在堆中划分一块区域给这个新对象。

3. 内存分配完成后，虚拟机需要对这个类进行初始化为零值（不针对于在TLAB中创建的对象，因为在TLAB分配空间时就顺带进行了初始化），但是不包括对象头，因为对象头存的是这个对象的信息。明显的感觉就是在Java中和c不一样，不用对每一个变量都进行初始化，c如果不初始化的话，那就会在编译期间报错。

4. 然后虚拟机对对象进行一系列必要的设置，也就是给它标识信息，也可以当作我们现代的身份证，比如它要保存这个对象是那个类的实例，那就相当于身份证上的籍贯，对象的哈希码也就相当于你的身份证号码，对象的GC分代年龄也就相当于你身份证上的年龄等等。这些东西全都放在对象头中，也就可以相当于是身份证。

5. 到此时，JVM的对象创建工作已经基本完成了，因为JVM按照流程制造了一个对象，现在再看看JVM初始化阶段，可以看到它给所有都赋值为空，这必定不是我们想要的结果吧。

6. JVM已经帮我们创建了一个空的对象，那就相当于给程序级别的对象创建提供了原材料，因此我们可以利用这个原材料进行加工和合理使用。因此，下来就对这个对象进行初始化操作-<init> ，按照我们的意愿来给对象加工。

7. 至此，一个崭新的对象就被创造出来了！


> 读完上边的文章，你会不会感觉有一些问题，反正我是有一些。比如我们在堆中是怎样进行内存分配的，又比如我们在创建对象的环境是一个高并发的环境，我们的分配速率可能达不到我们的接受速率（内存分配的本质也就是指针的移动），可能在一个很小的时间片段内有好多对象涌进来，导致一些内存分配的失败（也就是说JVM的预期和现实之间存在差距）。

### 针对堆中的内存分配问题

* 指针碰撞（Bump the Pointer）

在堆中内存是绝对工整的，把使用过的都放在一边，把没有使用过的都放在另一边，中间有指针分割，如果在这种情况下创建对象的话就只需要移动指针就可以实现了。这也就是指针碰撞。

* 空闲列表（Free List）

在堆中内存并不是工整的，那也就是已分配的空间和未分配的空间都是混乱的分布在堆中的，这种情况下，JVM就得维护一张表来记录空闲位置信息，如果此时需要创建一个对象的话，它就会找一个足够大的空间来分配给这个对象。

> 当然根据那个方式分配空间，是根据堆中的工整程度来进行选择的。当然不仅仅在于对象的内存分配，这些也会被用到垃圾回收中去。

### 解决并发带来的问题

那有人会说，那干脆就给创建入口添加一个封锁，每次只能一个进去，但是这显然是不可能的，因为这样的效率是真的太差了。因此在JVM中采用了下列两种的解决方案。

1. 对内存分配空间动作进行同步处理——CAS+失败重试（保证了原子性） 

这个操所基本就是一个后备手段，TLAB使用完了，基本才会使用这个。这仅仅是我自己的理解。因为TLAB的效率明显要高于CAS+失败重试。

2. 把内存分配的动作按照线程划分在不同空间中——本地线程分配缓冲（Thread Local Allocation Buffer）

就是在Java堆里边提前与分配一小块的内存给每一个线程，如果此线程里的对象要分配内存那就直接在TLAB中分配，不过TLAB中不够了那就采取第一种方式进行同步锁定。
  
## 对象的内存布局

> 在HostSpot中，对象在内存中存储的布局可以分为3块：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）。

### 对象头

1. 用来存储对象自身的运行时数据

比如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程的ID，偏向时间戳等。

这些数据的长度在32位机上就是32bit，64位机上就是64bit，官方称它位“mark word”，但是因为对象存储运行时的数据很多，可能会超过32bit或者64bit，Mark word是一个非固定的，以便于在极小的空间存更多的东西，还会根据对象状态来复用自己的存储空间。

2. 用来存储类型指针

虚拟机可以通过这个指针来找到是哪一个类的实例（执行类元数据的指针）。也就是说查找对象的元数据不一定要经过对象本身。

在我们的代码中，我们可以试一试，声明两个一维数组，并且要是同一类型的，然后使用“==”判读，我们会发现结果是true，那这是为什么呢？这是因为在存储数组元素的时候，存的是数据区域的首地址，那为什么我们在使用的时候结果不一样呢？那是因为在对象头中也同时保存的它的大小。通过大小就可以确定它的位置。我是这样认为的。

### 实例数据

保存的是对象真正存储的有效信息，也就是说是在程序中定义的字段内容（无论是自己的还是从父类继承的都需要记录起来）。在HotSpot中采用的是将同一宽度的数据放在一起，并且在这一条件下，父类的变量要在子类之前，在JVM有这样一个参数，CompactFields（自己翻译一下就是紧密的区域）设置为true（默认为true），那子类的变量也可能插到父类的空隙中。

### 对齐填充

> 对齐填充就相当于是充人数的，它没有什么实际的作用。

仅仅起着占位符的作用，因为在HotSpot VM中自动内存管理要求对象的起始地址必须是8字节的整数倍，对象头不用担心，因为它本来就是8的倍数，就仅仅是填充实例数据中的空位，填补空缺使它是8的倍数。

## 对象的访问定位

> 在前面我们了解了建立对象，我们也了解了对象的内部布局，因此就到了拿对象的时候了。

对对象的访问，Java程序需要通过栈上的reference来操作堆上的具体对象。

在目前有两种主流的访问方式：句柄访问和直接指针访问（HotSpot使用的是这个）

1. 句柄访问

什么是句柄访问，也就是在堆中划出一块区域作为句柄池（可以理解为中转站），里边存了很多的句柄，这些句柄和特定的reference用指针关联，然后在句柄中也放的都是执行不同资源的指针。

比如reference指向一个句柄（结构为：到对象实例数据的指针（堆里），到对象类型数据的指针（方法区）），使用三次指针定位。

2. 直接访问

在HotSpot中使用的是直接访问，因为在直接访问可以减少指针定位的次数，从而提高效率。

比如一个reference指向一个句柄（结构为：对象实例（直接指向），到对象类型数据的指针（方法去）），使用两次指针定位。

对比：这两个各有优缺，句柄访问最大的好处就是reference中存储的是稳定的句柄地址，对象的移动只需要改变到对象数据的指针就可以，reference就不用更改。直接访问最大的优点就是节省了指针定位的开销。