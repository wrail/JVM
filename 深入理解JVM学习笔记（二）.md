## Java虚拟机运行时数据区
<hr>
进入正题之前先来看看下边这张图，这是JVM运行时的数据区，也是上篇JVM中内存管理的第一个模块。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190405153935178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjA1OTY4,size_16,color_FFFFFF,t_70)

> 线程共享简单的说就是全局的，所有人都可以使用，线程独占就是只能自己使用。

接下来的主要目的就是吃透这张图。
### 线程共享区
<hr>
#### Java堆（Java Heap）

在JVM所管理的内存中，可以说Java堆是最大的一块。它是所有线程共享的，它在虚拟机启动的时候创建。**堆存在的目的就是为了存放对象实例，但并不是所有的对象实例都分配在堆上（由于JIT的发展和逃逸分析技术的逐渐成熟）**。

Java堆有这么多的对象实例，当然也就是垃圾回收管理的主要区域了，也有一个**别称叫它为GC（Garbage Collected Heap）堆**。可以从上一篇的图里看出，垃圾回收基本都采用的分代收集算法，因此Java堆里还可以细分为新生代和老年代（这里只简单提下一，后边详细区了解各种GC机制）。

Java虚拟机规范中说到Java堆可以处于物理不连续的区域，只需要逻辑连续就行。Java堆就像是磁盘一样，又可扩展的，也有不可扩展的，Java堆采用的前者，如果堆内存不够完成实例分配且无法扩展就会抛出OutOfMemory异常。

#### 方法区（Method Area）

方法区主要用于存储已经被虚拟机加载的类的信息，常量，静态变量，即时编译器编译后的代码等。

Java虚拟机规范将方法区描述为堆的一部分，它还有一个别名叫Non-Heap（非堆）。

Java虚拟机给了方法区一个很舒适的环境，它也不需要连续的内存空间，也可以选择固定大小或者扩展，**还可以选择不垃圾回收**，相对而言垃圾回收在此区域是比较少的，因此当非数据进入了方法区就相当于进入了永久代，基本不会被清除。使用不当就会抛出OutOfMemory异常。

> 关联扩展：运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分，为什么是方法区，就不多说了，读了上边的就知道了。

**Class文**件除了版本，字段，接口，方法等还有一项信息就是**Class文件常量池**，用于在编译期生成一些字面量和符号引用等。

运行时常量池相对于Class文件常量池重要特征就是具备动态性，Java语言并步要求常量一定只能在编译期间产生，运行期间也能将进的常量放进池里。

因为它是方法区的一部分，因此也会有OOM异常。

### 线程独占区
<hr>

#### 程序计数器（Program Counter Register）

程序计数器是相对较小的内存区域，可以看成当前线程所执行的字节码的行号指示器。

在JVM中也可以说是在各种各样的操作系统中都不能少了计数器这个模块，没有计数器模块，计算机就没有了指向标，失去了方向。可以说在JVM的每一步都需要它。

字节码解释器工作就是通过改变计数器的值来区下一条要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复，等一些基本功能都需要它。

> 为什么程序计数器是独占的？

因为在面向多线程的时候，每一条线程的状态或者执行状况都不同，因此每一个线程都必须要有自己的计数器，一个处理机，在一个时刻只能有一个线程指令在运行，因此计数器在线程切换后可以定位到上一次执行的位置。

> 值得一提的是，如果计数器记录的是正在执行的Java方法，那它记录的是虚拟字节码指令的地址。如果是Native方法就为空，是唯一一个在Java虚拟机上没规定任何OOM情况的区域。

#### 虚拟机栈（Java Virtual Machine Stacks）

虚拟机栈描述的是Java方法执行的内存模型： 每个方法在执行的同时都会创建一个栈帧用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

在其中局部变量表存的是**编译器可知的数据类型**（基本数据类型），对象引用（在Java核心基础中有详细的讲到），它可能是一个指针，句柄或是与此对象相关的位置信息，还有returnAdress类型（指向一条字节码指令的地址）。

> 在日常生活中总有人将Java内存分为堆和栈，堆就是前面讲的Java堆，栈就是虚拟机栈或虚拟机栈的一部分。

在基本类型中只有64为的long和double占用两个局部变量空间（Slot），其余的就只占一个。**局部变量表所需要的内存在编译期间就会完成分配**。当进入一个方法时，这个方法需要在帧中分配的局部变量空间大小也是完全确定的（因为它们都是一些可知的数据类型，在编译期间就分配好了），运行期间也不会改变局部变量表。

如果线程请求的栈深度大于所允许的深度（也就是装不下），就会抛出StackOverflowError，如果可以动态扩展的并且没有申请到足够的内存，就会抛出OOM。

#### 本地方法栈（Native Method Stack）

本地方法栈和虚拟机栈提供的服务十分相似，它们的主要区别就是虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈是为虚拟机使用到的Native方法服务。**在虚拟机规范中没有回答Native方法的语言，数据结构，因此可以采取任何语言和数据结构实现它**，这也就是有人说Native方法就是Java和其他语言的粘合剂。

它和虚拟机栈一样也会出现StackOverflow和OOM。在有的虚拟机就直接把本地方法栈和虚拟机栈合二为一了。

> 看完这部分后，可以发现会有很多原因而导致OOM或者StackOverflow的错误，因此了解JVM还是很有必要的。

## 直接内存（Direct Memory）

也就是本机内存，它不属于JVM运行时数据区，也不是JVM规范中定义的内存区域。在JDK1.4引入NIO类，引入了基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作（避免了Java堆和Native堆中来回复制数据，提高了效率）。但是，对然本机的内存不由Java堆大小的限制，但是内存和要是大于本机内存就会导致OOM异常。

> 堆外内存见名知意就是分配在Java虚拟机外的内存。这些受操作系统管理而不是JVM，因此也减轻了回收负担。

> 堆内内存 = 新生代+老年代+持久代
